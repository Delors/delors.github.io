<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="de" lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta content="Michael Eichberg" name="author" />
<meta content="&quot;IT Sicherheit&quot;, Passwortwiederherstellung" name="keywords" />
<meta content="Wiederherstellung von Passwörtern" lang="de" name="description" xml:lang="de" />
<meta content="lecture-security-passwort_wiederherstellung" name="id" />
<meta content="last-viewed" name="first-slide" />
<meta name="version" content="LD2 GENESIS" />
<meta name="exercises-passwords" content="MTAwMDAw:1Muq6aP7AlEIiCWQRAr1fJ1wxLNhz3pp0Wd2RxLWY4E=:bzFu8RfhgkOZL2Gr:1VIjCd1O8sL05TVD8qSqmcYTm1KMzLKY1VcAPMiKVXYUsWUH2YmJSIOe9Z9Kfql4Q8D3yXbh9F1H8uNM8lOqrWhDM7MrUdNj3k0LKNRZ9kcQNN87QwT5rXKEwn1C1xHQs4yiY5/ljHmxUZxWfUgCzYHNENrdiPq4hdAOqHoLknynDfpH2xvHbOMnqjAAlBOGK2NGms7ShHO7Pxwe8nU08elGLBRWRurUCCmDc8pI8BKtLaceEm8vYtaxPdDDcC3uU1bCJLI1sfHsLsqYlneSVkXX82w3WN4VkGUR7SwMeDpF/Rg4LPwcFeGPaKS7RUA=" />
<title>Passwortwiederherstellung</title>

    <script src="../LectureDoc2/genesis/ld-core.js" type="module"></script>

    <script src="../LectureDoc2/genesis/ld-components.js" type="module"></script>

    <link rel="stylesheet" href="../LectureDoc2/genesis/ld.css" />

    <link rel="stylesheet" href="../LectureDoc2/genesis/themes/DHBW/theme.css" />

    <link rel="stylesheet" href="../LectureDoc2/genesis/ld-ui.css" />

    
</head>
<body>
<template>
<div class="ld-slide" id="passwortwiederherstellung">
<h1 class="title">Passwortwiederherstellung</h1>
<dl class="docinfo">
<dt class="dozent">Dozent<span class="colon">:</span></dt>
<dd class="dozent"><p><a class="reference external" href="https://delors.github.io/cv/folien.de.rst.html">Prof. Dr. Michael Eichberg</a></p>
</dd>
<dt class="contact">Kontakt<span class="colon">:</span></dt>
<dd class="contact"><a class="reference external" href="mailto:michael.eichberg&#64;dhbw.de">michael.eichberg&#64;dhbw.de</a></dd>
<dt class="version">Version<span class="colon">:</span></dt>
<dd class="version">2.0</dd>
</dl>
<div class="supplemental">
<dl class="field-list">
<dt>Folien<span class="colon">:</span></dt>
<dd><p>[HTML] <a class="reference external" href="https://delors.github.io/sec-passwortwiederherstellung/folien.de.rst.html">https://delors.github.io/sec-passwortwiederherstellung/folien.de.rst.html</a></p>
<p>[PDF] <a class="reference external" href="https://delors.github.io/sec-passwortwiederherstellung/folien.de.rst.html.pdf">https://delors.github.io/sec-passwortwiederherstellung/folien.de.rst.html.pdf</a></p>
</dd>
<dt>Fehler melden<span class="colon">:</span></dt>
<dd><p><a class="reference external" href="https://github.com/Delors/delors.github.io/issues">https://github.com/Delors/delors.github.io/issues</a></p>
</dd>
</dl>
</div></div>
<div class="center-child-elements ld-slide" id="was-ist-passwortwiederherstellung">
<h2>Was ist Passwortwiederherstellung?</h2>
<aside class="admonition admonition-definition">
<p class="admonition-title">Definition</p>
<p>Passwortwiederherstellung ist der Prozess, der dazu dient, ein nicht (mehr) vorhandenes Passwort wiederzuerlangen.</p>
</aside>
<div class="supplemental">
<ul class="simple">
<li><p>Wer hat schon einmal Passworte wiederhergestellt?</p></li>
<li><p>Wer hat Erfahrung mit Linux?</p></li>
<li><p>Wer hat Erfahrung mit Linux Kommandozeilenwerkzeugen für die Verarbeitung von Dateien mit Text?</p></li>
<li><p>Wer hat Erfahrung mit regulären Ausdrücken?</p></li>
<li><p>Wer hat Erfahrung mit Python?</p></li>
<li><p>Wer hat Erfahrung mit Java (Reverse Engineering)?</p></li>
</ul>
</div></div><div class="ld-slide" id="passwortwiederherstellung-haftungsausschluss">
<h2>Passwortwiederherstellung -  Haftungsausschluss</h2>
<div class="stack smaller docutils container">
<div class="layer docutils container">
<blockquote class="epigraph">
<p>Wer unbefugt sich oder einem anderen Zugang zu Daten, die nicht für ihn bestimmt und die gegen unberechtigten Zugang besonders gesichert sind, unter Überwindung der Zugangssicherung verschafft, wird mit Freiheitsstrafe bis zu drei Jahren oder mit Geldstrafe bestraft.</p>
<p class="attribution">—§ 202 a Abs. 1 StGB</p>
</blockquote>
</div>
<div class="layer incremental docutils container">
<p><strong>Gericht sieht Nutzung von Klartext-Passwörtern als Hacken an</strong></p>
<blockquote class="epigraph">
<p>[...] Vor dem Amtsgericht wurde ein Prozess verhandelt, der die Gefahren verdeutlicht, denen sich Menschen mitunter aussetzen, die versuchen, Sicherheitslücken in der Software deutscher Firmen zu finden. Das Amtsgericht hat einen Programmierer verurteilt, der im Auftrag eines Kunden eine Software analysiert und darin eine Sicherheitslücke gefunden hatte, welche die Daten von Einkäufern in Online-Shops im Internet offengelegt hatte. Der Programmierer kontaktierte [...] die betroffene Firma, die daraufhin die Sicherheitslücke schloss und ihn anzeigte. Aufgrund dieses Umstandes wurde der Programmierer nun wegen unbefugten Zugriffs auf fremde Computersysteme und Ausspähens von Daten – welches unter dem sogenannten Hacker-Paragrafen 202a StGB unter Strafe gestellt ist – [...] verurteilt[...].</p>
<p class="attribution">—Heise.de - 19.01.2024 12:54 Uhr</p>
</blockquote>
</div>
</div>
</div><div class="ld-slide" id="wiederherstellung-von-passwortern">
<h2>Wiederherstellung von Passwörtern</h2>
<p>Welches Vorgehen müssen wir wählen, um Passworte der folgenden Art  wiederherzustellen?</p>
<ol class="arabic simple far-smaller">
<li><p>Donaudampfschifffahrt</p></li>
<li><p>Passwort</p></li>
<li><p>ME01703138541</p></li>
<li><p>2wsx3edc4rfv</p></li>
<li><p>Haus Maus</p></li>
<li><p>iluvu</p></li>
<li><p>Emily18</p></li>
<li><p>MuenchenHamburg2023!!!!</p></li>
<li><p>password123</p></li>
</ol>
<aside class="admonition smaller important">
<p class="admonition-title">Wichtig</p>
<p>Es gibt „einfach sichere Passworte“, die in vernünftiger Zeit mit angemessenen Ressourcen nicht wiederhergestellt werden können.</p>
</aside>
</div><div class="new-section transition-fade ld-slide" id="passwortwiederherstellung-101">
<h2>Passwortwiederherstellung 101</h2>
</div><div class="ld-slide" id="passwortwiederherstellung-1">
<h2>Passwortwiederherstellung</h2>
<ol class="arabic simple incremental dhbw">
<li><p>Wissen wo/in welcher Form der Passworthash zu finden ist.</p></li>
<li><p>Extraktion des Hashes</p></li>
<li><p>Wiederherstellung des Passwortes durch das systematische Durchprobieren aller Kandidaten.</p></li>
</ol>
</div><div class="ld-slide" id="beispiel-wiederherstellung-eines-linux-login-passwortes">
<h2>Beispiel - Wiederherstellung eines Linux Login Passwortes</h2>
<pre class="code bash incremental literal-block"><code>~%<span class="whitespace"> </span>sudo<span class="whitespace"> </span>cat<span class="whitespace"> </span>/etc/shadow<span class="whitespace">
</span><span class="operator">[</span>...<span class="operator">]</span><span class="whitespace">
</span>john:<span class="name variable">$6$zElzjLsMqi36JXWG$FX2Br1</span>/<span class="operator">[</span>...<span class="operator">]</span>.<span class="whitespace"> </span>↩︎<span class="whitespace">
</span>RxAHnNCBsqiouWUz751crHodXxs0iqZfBt9j40l3G0:19425:0:99999:7:::<span class="whitespace">
</span><span class="operator">[</span>...<span class="operator">]</span></code></pre>
<pre class="code bash incremental line-above literal-block"><code>%<span class="whitespace"> </span><span class="name builtin">echo</span><span class="whitespace"> </span>-n<span class="whitespace"> </span><span class="literal string single">'$6$zElzjLsMqi36JXWG$FX2Br1/[...]. ↩︎
RxAHnNCBsqiouWUz751crHodXxs0iqZfBt9j40l3G0'</span><span class="whitespace"> </span>&gt;<span class="whitespace"> </span>hash.txt</code></pre>
<pre class="code bash incremental line-above literal-block"><code>%<span class="whitespace"> </span>hashcat<span class="whitespace"> </span>-m<span class="whitespace"> </span><span class="literal number">1800</span><span class="whitespace"> </span>hash.txt<span class="whitespace"> </span>-a<span class="whitespace"> </span><span class="literal number">3</span><span class="whitespace"> </span><span class="literal string single">'?d?d?d?d?d?d'</span></code></pre>
<div class="supplemental">
<p><strong>Finden eines Hashes</strong></p>
<p>Im Falle von Linux Login Passworten ist genau spezifiziert wo die Passworte (<span class="docutils literal">/etc/shadow</span>) und in welcher Form die Passworte gespeichert werden. Nach dem Namen des Nutzers (im Beispiel <span class="docutils literal">john</span>) ist der verwendete Hashingalgorithmus vermerkt. Dieser unterscheidet sich zwischen den Distributionen. Aktuell setzen die meisten Distributionen auf <span class="docutils literal">yescrypt</span>. Danach folgen die Parameter. Insbesondere der Salt.</p>
<table>
<thead>
<tr><th class="head"><p>ID</p></th>
<th class="head"><p>Mode</p></th>
</tr>
</thead>
<tbody>
<tr><td><p>$5$</p></td>
<td><p>Sha256crypt (veraltet)</p></td>
</tr>
<tr><td><p>$6$</p></td>
<td><p>SHA512crypt (in Ablösung)</p></td>
</tr>
<tr><td><p>$y$ (or $7$)</p></td>
<td><p>yescrypt</p></td>
</tr>
</tbody>
</table>
</div></div><div class="ld-slide" id="systematisches-testen-aller-kandidaten">
<h2>Systematisches Testen aller Kandidaten</h2>
<p>Konzeptionell führt die Software Hashcat die folgenden Schritte durch:</p>
<div class="monospaced small docutils container">
<p>&lt;extracted_hash&gt; =? SHA512crypt(&quot;zElzjLsMqi36JXWG&quot;,&quot;000000&quot;) ✘</p>
<p class="incremental">&lt;extracted_hash&gt; =? SHA512crypt(&quot;zElzjLsMqi36JXWG&quot;,&quot;000001&quot;) ✘</p>
<p class="incremental">&lt;extracted_hash&gt; =? SHA512crypt(&quot;zElzjLsMqi36JXWG&quot;,&quot;000002&quot;) ✘</p>
<p class="incremental">&lt;extracted_hash&gt; =? SHA512crypt(&quot;zElzjLsMqi36JXWG&quot;,&quot;000003&quot;) ✘</p>
<p class="incremental">&lt;extracted_hash&gt; =? SHA512crypt(&quot;zElzjLsMqi36JXWG&quot;,&quot;000004&quot;) ✘</p>
<p class="incremental">&lt;extracted_hash&gt; =? SHA512crypt(&quot;zElzjLsMqi36JXWG&quot;,&quot;000005&quot;) ✘</p>
<p class="incremental">&lt;extracted_hash&gt; =? SHA512crypt(&quot;zElzjLsMqi36JXWG&quot;,&quot;000006&quot;) ✘</p>
<p class="incremental">&lt;extracted_hash&gt; =? SHA512crypt(&quot;zElzjLsMqi36JXWG&quot;,&quot;000007&quot;) ✘</p>
<p class="incremental">&lt;extracted_hash&gt; =? SHA512crypt(&quot;zElzjLsMqi36JXWG&quot;,&quot;000008&quot;) ✘</p>
<p class="incremental">...</p>
<p class="incremental">&lt;extracted_hash&gt; == SHA512crypt(&quot;zElzjLsMqi36JXWG&quot;,&quot;123456&quot;) ✔︎</p>
</div>
<div class="supplemental">
<p>Der folgende Code könnte als Grundlage genutzt werden, um das Passwort wiederherzustellen.</p>
<p>(Linux nutzt standardmäßig 5000 Runden.)</p>
<pre class="code python slightly-smaller literal-block"><code><span class="keyword namespace">from</span><span class="whitespace"> </span><span class="name namespace">passlib.hash</span><span class="whitespace"> </span><span class="keyword namespace">import</span> <span class="name">sha512_crypt</span><span class="whitespace">

</span><span class="name">sha512_crypt</span><span class="operator">.</span><span class="name">hash</span><span class="punctuation">(</span><span class="whitespace">
</span>    <span class="literal string double">&quot;123456&quot;</span><span class="punctuation">,</span><span class="whitespace">
</span>    <span class="name">salt</span><span class="operator">=</span><span class="literal string double">&quot;zElzjLsMqi36JXWG&quot;</span><span class="punctuation">,</span><span class="whitespace">
</span>    <span class="name">rounds</span><span class="operator">=</span><span class="literal number integer">5000</span><span class="punctuation">)</span></code></pre>
</div></div><div class="new-section transition-scale ld-slide" id="werkzeuge-und-methoden-zur-wiederherstellung-von-passwortern">
<h2>Werkzeuge und Methoden zur Wiederherstellung von Passwörtern</h2>
</div><div class="ld-slide" id="passwortwiederherstellung-2">
<h2>Passwortwiederherstellung</h2>
<p class="rubric">initiale Quellen für Passwortkandidaten</p>
<ul class="smaller simple">
<li><p>Wörterbücher</p></li>
<li><p>Verzeichnisse (z. B. Postleitzahlen, Städte, Straßennamen)</p></li>
<li><p>Leaks (z. B. Rockyou, LinkedIn, Sony)</p></li>
</ul>
<p class="rubric">Werkzeuge zum Generieren von weiteren Passwortkandidaten</p>
<ul class="smaller simple">
<li><p>Prince</p></li>
<li><p>OMEN (Markov-Modelle</p></li>
<li><p>Hashcat</p></li>
<li><p>PCFG</p></li>
</ul>
<p class="rubric">Werkzeuge, um Passworthashes zu extrahieren bwz. anzugreifen</p>
<ul class="smaller simple">
<li><p>John (the Ripper)</p></li>
<li><p>Hashcat</p></li>
</ul>
</div><div class="new-subsection ld-slide" id="grundlegende-werkzeuge">
<h2>Grundlegende Werkzeuge</h2>
<ul class="simple">
<li><p><a class="reference external" href="../lab-shell/folien.de.rst.html">Linux Shell</a></p></li>
<li><p><a class="reference external" href="../lab-regexp/folien.de.rst.html">Reguläre Ausdrücke</a></p></li>
</ul>
</div><div class="new-subsection transition-fade ld-slide" id="extraktion-von-hashes">
<h2>Extraktion von Hashes</h2>
<div class="supplemental">
<p><strong>Hinweis</strong></p>
<p>Im Folgenden diskutieren wir nur exemplarisch die Extraktion einiger Hashes, um das grundlegende Vorgehen zu besprechen. Im Allgemeinen gibt es für weit(er) verbreitete Software häufig bereits Lösungen zur Hashextraktion. Falls nicht, dann muss man Googeln und/oder Reverse Engineering betreiben.</p>
</div></div><div class="ld-slide" id="quellen-fur-werkzeuge-anleitungen">
<h2>Quellen für Werkzeuge &amp; Anleitungen</h2>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/hashcat/hashcat/tree/master/tools">Hashcat Tools</a></p></li>
<li><p><a class="reference external" href="https://github.com/openwall/john">John (the Ripper)</a></p></li>
<li><p>Googeln</p></li>
<li><p>KI Assistent (z. B.) ChatGPT</p></li>
</ul>
<div class="supplemental class far-smaller">
<p class="rubric">Konversation mit ChatGPT (23. August 2024)</p>
<div class="far-far-smaller docutils container">
<p>Im Folgenden wurde Anpassungen der Formatierung vorgenommen, zwecks Integration in den Foliensatz. Die Inhalte sind jedoch vollständig von ChatGPT erstellt.</p>
</div>
<div class="text-align-right dhbw-light-gray-background italic padding-1em docutils container">
<p><strong>Prompt</strong></p>
<p>Wie extrahiere ich den Hash eines Passworts eines Nutzers unter Ubuntu Linux?</p>
</div>
<p><strong>Antwort</strong></p>
<p>Um den Hash eines Passworts eines Nutzers unter Ubuntu Linux zu extrahieren, müssen Sie Zugriff auf die Datei /etc/shadow haben, da diese Datei die gehashten Passwörter enthält. Folgende Schritte sind notwendig:</p>
<ol class="arabic">
<li><p>Root-Rechte erlangen:</p>
<blockquote>
<p>Da die Datei /etc/shadow nur von root gelesen werden kann, müssen Sie entweder als root angemeldet sein oder sudo verwenden.</p>
</blockquote>
</li>
<li><p>Öffnen der /etc/shadow Datei:</p>
<blockquote>
<p>Sie können die Datei mit einem Texteditor oder einem Kommandozeilen-Tool wie cat, less, oder grep öffnen.</p>
<p>Beispiel mit cat:</p>
<pre class="code bash literal-block"><code>sudo<span class="whitespace"> </span>cat<span class="whitespace"> </span>/etc/shadow</code></pre>
</blockquote>
</li>
<li><p>Suchen des entsprechenden Benutzers:</p>
<blockquote>
<p>Suchen Sie nach der Zeile, die mit dem Benutzernamen beginnt, dessen Passwort-Hash Sie extrahieren möchten. Diese Zeile hat das folgende Format:</p>
<pre class="code text literal-block"><code>benutzername:$id$salt$hash:weitere_felder</code></pre>
<p>Der Hash des Passworts ist der Teil nach dem zweiten $ Zeichen. Hier ein Beispiel für eine Zeile aus der /etc/shadow Datei:</p>
<pre class="code text literal-block"><code>username:$6$salt$hashed_password:date:0:99999:7:::</code></pre>
<p>In diesem Fall ist hashed_password der Passwort-Hash des Benutzers.</p>
</blockquote>
</li>
<li><p>Extraktion des Passwort-Hashes:</p>
<blockquote>
<p>Wenn Sie nur den Hash extrahieren möchten, können Sie den Befehl grep zusammen mit cut verwenden:</p>
<pre class="code bash literal-block"><code>sudo<span class="whitespace"> </span>grep<span class="whitespace"> </span><span class="literal string single">'username'</span><span class="whitespace"> </span>/etc/shadow<span class="whitespace"> </span><span class="punctuation">|</span><span class="whitespace"> </span>cut<span class="whitespace"> </span>-d:<span class="whitespace"> </span>-f2</code></pre>
<p>Dieser Befehl extrahiert den gesamten Hash einschließlich des ID- und Salt-Teils, also z.B.:</p>
<pre class="code text literal-block"><code>$6$salt$hashed_password</code></pre>
<p>Falls Sie nur den Hash ohne den ID- und Salt-Teil [...]</p>
</blockquote>
</li>
</ol>
<aside class="admonition hint">
<p class="admonition-title">Hinweis</p>
<p>Der Zugriff auf und das Bearbeiten von /etc/shadow sollte sehr vorsichtig und verantwortungsbewusst durchgeführt werden, da unsachgemäße Änderungen zu Sicherheitsproblemen oder sogar zum Verlust des Zugangs zum System führen können.</p>
</aside>
</div></div><div class="ld-slide" id="relevante-linux-kommandozeilenwerkzeuge">
<h2>Relevante Linux Kommandozeilenwerkzeuge</h2>
<ul class="incremental">
<li><p><span class="docutils literal">file</span> dient der Ermittlung des Typs einer Datei.</p></li>
<li><p><span class="docutils literal">binwalk</span> durchsucht Binärdateien in Hinblick auf das Vorkommen bekannter Muster (insbsondere Dateiheader, aber auch Kryptokonstanten etc.)</p>
<p><span class="docutils literal"><span class="pre">-E</span></span> kann zur Visualisierung der Entropie verwendet werden.</p>
</li>
<li><p><span class="docutils literal">dd</span> kopiert Daten blockweise von einem Startpunkt in einer Datei in eine andere Datei. Wird ggf. zum Extrahieren von Hashes benötigt.</p></li>
<li><p><span class="docutils literal">xxd</span> und <span class="docutils literal">hexdump</span> erstellen beide einen Hexdump einer Datei.</p></li>
</ul>
</div><div class="ld-slide" id="verschlusselte-pdf-dateien">
<h2>Verschlüsselte PDF Dateien</h2>
<p>Extraktion erfolgt (zum Beispiel) mit den John Tools:</p>
<pre class="code bash literal-block"><code>$<span class="whitespace"> </span>pdf2john<span class="whitespace"> </span>Document.pdf<span class="whitespace"> </span>&gt;<span class="whitespace"> </span>Document.pdf.john<span class="whitespace">
</span>$<span class="whitespace"> </span>cat<span class="whitespace"> </span>Document.pdf.john<span class="whitespace">
</span>Document.pdf:<span class="name variable">$pdf$4</span>*4*128*-3392*1*16*861da8b9c1672ddc3953dee025<span class="whitespace">
</span>5d622d*32*301d0810078c5698ab17b286e2123070000000000000000000000<span class="whitespace">
</span><span class="literal number">00000000000</span>*32*c038ddb8fbdaeb67b6e80e2d936108fc851ff40c5b652c71<span class="whitespace">
</span>97bda4f797939532</code></pre>
<p>Danach kann der Hash entweder direkt mit John angegriffen werden, oder nach dem Entfernen des Headers mit Hashcat.</p>
<pre class="code bash literal-block"><code>$<span class="whitespace"> </span>pdf2john<span class="whitespace"> </span>Document.pdf<span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace">  </span><span class="punctuation">|</span><span class="whitespace"> </span>sed<span class="whitespace"> </span>-E<span class="whitespace"> </span><span class="literal string double">&quot;s/^[^:]+://&quot;</span><span class="whitespace">        </span><span class="comment single"># Dateiname entfernen
</span><span class="whitespace">  </span>&gt;<span class="whitespace"> </span>Document.pdf.hashcat</code></pre>
</div><div class="ld-slide" id="libreoffice-dateien">
<h2>Libreoffice Dateien</h2>
<p>Extraktion des Basishashes erfolgt auch hier (zum Beispiel) mit den John Tools. Danach muss sowohl der Prefix als auch der Suffix, der für die Entschlüsselung nicht relevant ist, abgeschnitten werden, wenn im Folgenden Hashcat verwendet werden soll.</p>
<pre class="code bash literal-block"><code>$<span class="whitespace"> </span>libreoffice2john<span class="whitespace"> </span>Document.odt<span class="whitespace">
  </span><span class="punctuation">|</span><span class="whitespace"> </span>sed<span class="whitespace"> </span>-E<span class="whitespace"> </span>-e<span class="whitespace"> </span><span class="literal string single">'s/[^:]+://'</span><span class="whitespace"> </span>-e<span class="whitespace"> </span><span class="literal string single">'s/:::::[^:]+$//'</span><span class="whitespace">
  </span>&gt;<span class="whitespace"> </span>Document.odt.hashcat</code></pre>
<div class="incremental docutils container">
<p>Um zu verstehen, wie der Hash genau auszusehen hat, ist es im Allgemeinen hilfreich sich die erwartete Struktur für einen Hash anzusehen: <a class="reference external" href="https://hashcat.net/wiki/doku.php?id=example_hashes">Hashcat - Example Hashes</a></p>
</div>
</div><div class="ld-slide" id="verschlusselte-mac-disk-images-dmg">
<h2>Verschlüsselte Mac Disk Images (.dmg)</h2>
<p>In diesem Fall hat nur John (the Ripper) Unterstützung für den konkreten Hash.</p>
<pre class="code bash literal-block"><code>$<span class="whitespace"> </span>dmg2john<span class="whitespace"> </span>Container.dmg<span class="whitespace"> </span>&gt;<span class="whitespace"> </span>Container.dmg.john<span class="whitespace">   </span><span class="comment single"># Extraktion</span></code></pre>
<pre class="code bash incremental literal-block"><code>$<span class="whitespace"> </span>john<span class="whitespace"> </span>Container.dmg.john<span class="whitespace"> </span><span class="literal string escape">\ </span><span class="whitespace">                    </span><span class="comment single"># Angriff
</span><span class="whitespace">  </span>--wordlist<span class="operator">=</span>/usr/share/wordlists/rockyou.txt</code></pre>
</div><div class="ld-slide" id="verschlusselter-usb-stick-apfs-volume">
<h2>Verschlüsselter USB Stick (APFS Volume)</h2>
<p>Es liegt ein normaler USB Stick vor auf dem eine Partition vom Typ <span class="docutils literal">Apple APFS</span> ist.</p>
<pre class="smaller literal-block">Disk /dev/sda: 14.45 GiB, 15518924800 bytes, 30310400 sectors
Disk model: Flash Disk
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: 1D63D8AE-7CBC-47BE-9093-8469B0786EAF

Device      Start      End  Sectors  Size Type
/dev/sda1      40   409639   409600  200M EFI System
/dev/sda2  409640 30310359 29900720 14.3G Apple APFS</pre>
</div><div class="ld-slide" id="verschlusselter-usb-stick-apfs-volume-1">
<h2>Verschlüsselter USB Stick (APFS Volume)</h2>
<ol class="arabic">
<li><p>Installation von <a class="reference external" href="https://github.com/Banaanhangwagen/apfs2hashcat">apfs2hashcat</a> (umfasst das Kompilieren der Sourcen)</p></li>
<li><p>Hash extrahieren durch „Copy-and-Paste“ aus dem Logfile/der Konsole.</p>
<pre class="code bash literal-block"><code>$<span class="whitespace"> </span>sudo<span class="whitespace"> </span>./apfs-dump-quick<span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace">  </span>/dev/sda2<span class="whitespace"> </span><span class="literal string escape">\ </span><span class="whitespace">  </span><span class="comment single"># /dev/sda2 ist die Ziel APFS Partition
</span><span class="whitespace">  </span>/tmp/log.txt</code></pre>
</li>
<li><p>Hash angreifen</p>
<pre class="code bash incremental literal-block"><code>$<span class="whitespace"> </span>hashcat<span class="whitespace"> </span>-m<span class="whitespace"> </span><span class="literal number">18300</span><span class="whitespace"> </span>fv2.hashcat<span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace">  </span>/usr/share/wordlists/rockyou.txt</code></pre>
</li>
</ol>
</div><div class="new-subsection transition-fade ld-slide" id="passwortwiederherstellung-mit-hashcat">
<h2>Passwortwiederherstellung mit Hashcat</h2>
</div><div class="ld-slide" id="hashcat-einfuhrung">
<h2>Hashcat - Einführung</h2>
<p>Hashcat ist – Stand 2024 – das Tool zum Wiederherstellen von Passwörtern.</p>
<p>Liest ein(e Liste von) Hash(es) ein und prüft, ob einer der angegebenen Passwortkandidaten nach dem Hashen mit einem gegeben Hash übereinstimmt.</p>
<ul class="incremental simple">
<li><p>unterstützt über 350 Hash-Typen (mit einigen automatischen Erkennungen)</p></li>
<li><dl class="simple">
<dt>unterstützt mehrere Angriffsmodi, z. B.,</dt>
<dd><ul>
<li><p>Wörterbuch (ggf. mit Regeln)</p></li>
<li><p>Masken</p></li>
<li><p>Kombinationen aus Wörterbüchern und Masken</p></li>
<li><p>&lt;Lesen von Passwortkandidaten aus stdin&gt;</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Open-Source</p></li>
<li><p>Kann zum Generieren von neuen Kandidaten verwendet werden.</p></li>
<li><p>ist CUDA/OpenCL basiert und <strong>auf entsprechenden Grafikkarten extrem schnell</strong>.</p></li>
</ul>
</div><div class="ld-slide" id="hashcat-relevante-parameter">
<h2>Hashcat - relevante Parameter</h2>
<div class="two-columns smaller docutils container">
<div class="column padding-right-1em docutils container">
<p>Angriffsmodi:</p>
<pre class="code bash literal-block"><code>-a0<span class="whitespace"> </span>Angriff<span class="whitespace"> </span>mit<span class="whitespace"> </span>Wörterbuch<span class="whitespace">
    </span><span class="operator">(</span>ggf.<span class="whitespace"> </span>mit<span class="whitespace"> </span>Regeln<span class="whitespace"> </span>-r<span class="operator">)</span><span class="whitespace">

</span>-a1<span class="whitespace"> </span>Kombinationsangriff<span class="whitespace">
    </span>Angriff<span class="whitespace"> </span>mit<span class="whitespace"> </span>dem<span class="whitespace"> </span>Kreuzprodukt<span class="whitespace">
    </span>zweier<span class="whitespace"> </span>Wörterbücher.<span class="whitespace">

</span>-a3<span class="whitespace"> </span>Brute-force<span class="whitespace"> </span>Angriff<span class="whitespace">

</span>-a6<span class="whitespace"> </span>Hybridangriff<span class="whitespace">
    </span>Wörterbuch<span class="whitespace"> </span>und<span class="whitespace"> </span>Maske</code></pre>
</div>
<div class="column margin-left-1em docutils container">
<p>Brute-force - Eingebaute Zeichensätze:</p>
<p class="monospaced">?l = abcdefghijklmnopqrstuvxyz</p>
<p class="monospaced">?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ</p>
<p class="monospaced">?d = 0123456789</p>
<p class="monospaced">?s = !&quot;$%&amp;'()*+,-./:;&lt;=&gt;?&#64;[]^_{|}~</p>
<p class="monospaced">?a = ?l?u?d?s</p>
<p>Definition von bis zu 4 eigenen Zeichensätzen (?1,...,?4) ist möglich.</p>
</div>
</div>
</div><div class="ld-slide" id="hashcat-ausgewahlte-regeln">
<h2><a class="reference external" href="https://hashcat.net/wiki/doku.php?id=rule_based_attack">Hashcat - Ausgewählte Regeln</a></h2>
<p>(Die Regeln sind teilweise John kompatibel.)</p>
<table class="small incremental">
<thead>
<tr><th class="head"><p>Name</p></th>
<th class="head"><p>Function</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Input</p></th>
<th class="head"><p>Output</p></th>
</tr>
</thead>
<tbody>
<tr><td><p>Nothing</p></td>
<td><p>:</p></td>
<td><p>Do nothing (passthrough)</p></td>
<td><p><span class="docutils literal">p&#64;ssW0rd</span></p></td>
<td><p><span class="docutils literal">p&#64;ssW0rd</span></p></td>
</tr>
<tr><td><p>Lowercase</p></td>
<td><p>l</p></td>
<td><p>Lowercase all letters</p></td>
<td><p><span class="docutils literal">p&#64;ssW0rd</span></p></td>
<td><p><span class="docutils literal">p&#64;ssw0rd</span></p></td>
</tr>
<tr><td><p>Uppercase</p></td>
<td><p>u</p></td>
<td><p>Uppercase all letters</p></td>
<td><p><span class="docutils literal">p&#64;ssW0rd</span></p></td>
<td><p><span class="docutils literal">P&#64;SSW0RD</span></p></td>
</tr>
<tr><td><p>Capitalize</p></td>
<td><p>c</p></td>
<td><p>Capitalize the first letter and lower the rest</p></td>
<td><p><span class="docutils literal">p&#64;ssW0rd</span></p></td>
<td><p><span class="docutils literal">P&#64;ssw0rd</span></p></td>
</tr>
<tr><td><p>Toggle Case</p></td>
<td><p>t</p></td>
<td><p>Toggle the case of all characters in word.</p></td>
<td><p><span class="docutils literal">p&#64;ssW0rd</span></p></td>
<td><p><span class="docutils literal">P&#64;SSw0RD</span></p></td>
</tr>
<tr><td><p>Reverse</p></td>
<td><p>r</p></td>
<td><p>Reverse the entire word</p></td>
<td><p><span class="docutils literal">p&#64;ssW0rd</span></p></td>
<td><p><span class="docutils literal">dr0Wss&#64;p</span></p></td>
</tr>
<tr><td><p>Duplicate</p></td>
<td><p>d</p></td>
<td><p>Duplicate entire word</p></td>
<td><p><span class="docutils literal">p&#64;ssW0rd</span></p></td>
<td><p><span class="docutils literal">p&#64;ssW0rdp&#64;ssW0rd</span></p></td>
</tr>
<tr><td><p>Append</p></td>
<td><p>$X</p></td>
<td><p>Append X to the end</p></td>
<td><p><span class="docutils literal">p&#64;ssW0rd</span></p></td>
<td><p><span class="docutils literal">p&#64;ssW0rdX</span></p></td>
</tr>
<tr><td><p>Prepend</p></td>
<td><p>^X</p></td>
<td><p>Prepend X at the beginning</p></td>
<td><p><span class="docutils literal">p&#64;ssW0rd</span></p></td>
<td><p><span class="docutils literal">Xp&#64;ssW0rd</span></p></td>
</tr>
<tr><td><p>...</p></td>
<td><p>...</p></td>
<td><p>...</p></td>
<td><p>...</p></td>
<td><p>...</p></td>
</tr>
</tbody>
</table>
</div><div class="small ld-slide" id="szenario-1-eine-pin-angreifen">
<h2>Szenario 1: eine Pin Angreifen</h2>
<p><strong>Ausgangssituation</strong></p>
<p>Gegeben sein ein mit SHA256 gehashter 5-stelliger Pin in der Datei: <span class="docutils literal">5_digits_pin.sha256</span>.</p>
<p>Hashwert:</p>
<div class="monospaced docutils container">
<p><span class="docutils literal">79737ac46dad121166483e084a0727e5d6769fb47fa9b0b627eba4107e696078</span></p>
</div>
<p><strong>Angriff mit Maske</strong></p>
<pre class="code bash incremental literal-block"><code>hashcat<span class="whitespace"> </span>-m<span class="whitespace"> </span><span class="literal number">1400</span><span class="whitespace"> </span>5_digits_pin.sha256<span class="whitespace"> </span>-a3<span class="whitespace"> </span><span class="literal string double">&quot;?d?d?d?d?d&quot;</span></code></pre>
<div class="incremental docutils container">
<dl class="field-list simple">
<dt>-m 1400<span class="colon">:</span></dt>
<dd><p>Modus für einen einfachen SHA256 Hash.</p>
</dd>
<dt>-a3<span class="colon">:</span></dt>
<dd><p>bezeichnet einen Maskenangriffe</p>
</dd>
<dt>&quot;?d?d?d?d?d&quot;<span class="colon">:</span></dt>
<dd><p>Beschreibt die Maske. Hier 5 Ziffern (<span class="eng">digits</span>).</p>
</dd>
</dl>
</div>
</div><div class="small ld-slide" id="szenario-2-ein-hoffentlich-einfaches-loginpasswort-angreifen">
<h2>Szenario 2: Ein (hoffentlich) einfaches Loginpasswort angreifen</h2>
<p><strong>Ausgangssituation</strong></p>
<p>Ein mit SHA512crypt gehashtes Passwort in der Datei: <span class="docutils literal">password.sha512crypt</span>.</p>
<p><strong>Angriff mit Wörterbuch</strong></p>
<pre class="code bash literal-block"><code>hashcat<span class="whitespace"> </span>password.sha512crypt<span class="whitespace"> </span>-a0<span class="whitespace"> </span>/usr/share/wordlists/rockyou.txt</code></pre>
<div class="incremental docutils container">
<dl class="field-list simple">
<dt>-a0<span class="colon">:</span></dt>
<dd><p>bezeichnet einen Wörterbuchangriff.</p>
</dd>
<dt>/usr/share/wordlists/rockyou.txt<span class="colon">:</span></dt>
<dd><p>Das zum Angriff verwendete Wörterbuch; der Pfad ist der Standardpfad zum Rockyou Wörterbuch in Kali Linux.</p>
</dd>
</dl>
</div>
</div><div class="small ld-slide" id="szenario-3-ein-komplexeres-passwort-angreifen">
<h2>Szenario 3: ein komplexeres Passwort angreifen</h2>
<p><strong>Ausgangssituation</strong></p>
<p>Ein mit MD5 gehashtes Passwort in der Datei: <span class="docutils literal">password.md5</span>. Ein erster Angriff mit Rockyou war nicht erfolgreich.</p>
<p><strong>Angriff mit Wörterbuch und Regelsatz</strong></p>
<pre class="code bash incremental literal-block"><code>hashcat<span class="whitespace"> </span>-m<span class="whitespace"> </span><span class="literal number">0</span><span class="whitespace"> </span>password.md5<span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace">            </span>-a0<span class="whitespace"> </span>/usr/share/wordlists/rockyou.txt<span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace">            </span>-r<span class="whitespace"> </span>/usr/share/hashcat/rules/best64.rule</code></pre>
<div class="incremental docutils container">
<dl class="field-list">
<dt>-a0<span class="colon">:</span></dt>
<dd><p>bezeichnet einen Wörterbuchangriff.</p>
</dd>
<dt>/usr/share/wordlists/rockyou.txt<span class="colon">:</span></dt>
<dd><p>Das zum Angriff verwendete Wörterbuch.</p>
</dd>
<dt>-r /usr/share/hashcat/rules/best64.rule<span class="colon">:</span></dt>
<dd><p>Der zum Beugen der Passwortkandidaten verwendete Regelsatz.</p>
<p>Der Regelsatz best64 hat sich in einem Wettbewerb als „bester“ Regelsatz erwiesen.</p>
</dd>
</dl>
</div>
</div><div class="small ld-slide" id="szenario-4-ein-passwort-mit-salt-angreifen">
<h2>Szenario 4: ein Passwort mit Salt angreifen</h2>
<p><strong>Ausgangssituation</strong></p>
<p>Ein MD5 Hash ist gegeben: <span class="docutils literal">c84b5c34c9ff7d3431018d795b5975e5</span>. Weiterhin ist bekannt, dass der verwendete <em>Salt</em> <span class="docutils literal">SALT</span> ist.</p>
<p><strong>Angriff</strong></p>
<ol class="arabic incremental">
<li><p>Modus für MD5+Salt heraussuchen (<span class="docutils literal"><span class="pre">-m10</span></span>); ggf. Beispielhash ansehen, um zu verstehen, wie der Hash aufgebaut ist.</p></li>
<li><p>Erzeugen des Hashes für Hashcat:</p>
<pre class="code bash literal-block"><code><span class="name builtin">echo</span><span class="whitespace"> </span>-n<span class="whitespace"> </span><span class="literal string double">&quot;c84b5c34c9ff7d3431018d795b5975e5:SALT&quot;</span><span class="whitespace"> </span>&gt;<span class="whitespace"> </span>salted.m5.hash</code></pre>
</li>
<li><p>Mit Hashcat angreifen:</p>
<pre class="code bash literal-block"><code>hashcat<span class="whitespace"> </span>-m10<span class="whitespace"> </span>salted.md5.hash<span class="whitespace">  </span>-a3<span class="whitespace"> </span><span class="literal string single">'?a?a?a?a'</span></code></pre>
</li>
</ol>
<div class="supplemental">
<p><strong>Lösung</strong></p>
<p>Das Passwort ist <span class="docutils literal">Test</span>. In diesem Fall wäre es auch möglich gewesen direkt zu Prüfen ob das Passwort <span class="docutils literal">Test</span> ist, indem man Hashcat im Modus -m0 (für reinen MD5) startet und als Kandidaten <span class="docutils literal">TestSALT</span> vorgibt.</p>
</div></div><div class="small ld-slide" id="szenario-5-kombination-von-worterbuch-mit-eigenem-regelsatz">
<h2>Szenario 5: Kombination von Wörterbuch mit eigenem Regelsatz</h2>
<p><strong>Ausgangssituation</strong></p>
<p>Wir greifen einen sogennanten langsamen Hash an und können deswegen nur wenige Passworte gezielt testen.</p>
<p>Aufgrund von Social Engineering/Ermittlungen wissen wir, dass die Person häufig kurze Worte (max 4 Buchstaben nimmt) diese aber oft verdoppelt und häufig die Worte mit einem Großbuchstaben anfangen lässt.</p>
<p><strong>Angriff</strong></p>
<ol class="arabic simple incremental">
<li><p>Erstellen eines fokussierten Wörterbuchs: <span class="docutils literal">candidates.txt</span>.</p></li>
<li><p>Erstellen des Regelsatzes: <span class="docutils literal">case.rule</span>.</p></li>
<li><p>Angriff mit den erstellten Wörterbuch und dem Regelsatz.</p></li>
</ol>
</div><div class="small ld-slide" id="szenario-5-kombination-von-worterbuch-mit-eigenem-regelsatz-1">
<h2>Szenario 5: Kombination von Wörterbuch mit eigenem Regelsatz</h2>
<p><strong>Angriff</strong></p>
<ol class="arabic">
<li><p>Generierung von <span class="docutils literal">candidates.txt</span></p>
<p>Um sicherzustellen, dass wir keine Duplikate testen, wandeln wir alle Worte in Kleinschreibung um und filtern entsprechende Duplikate. Die Beachtung aller Varianten in Hinblick auf die Groß- und Kleinschreibung wird durch die Regeln sichergestellt.</p>
<pre class="code bash literal-block"><code>$<span class="whitespace"> </span>grep<span class="whitespace"> </span>-Po<span class="whitespace"> </span><span class="literal string double">&quot;^[a-zA-Z]{3,4}(?=[^a-zA-Z])&quot;</span><span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace">       </span>/usr/share/wordlists/rockyou.txt<span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace">  </span><span class="punctuation">|</span><span class="whitespace"> </span>tr<span class="whitespace"> </span><span class="operator">[</span>:upper:<span class="operator">]</span><span class="whitespace"> </span><span class="operator">[</span>:lower:<span class="operator">]</span><span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace">  </span><span class="punctuation">|</span><span class="whitespace"> </span>sort<span class="whitespace"> </span>-u<span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace">  </span>&gt;<span class="whitespace"> </span>candidates.txt</code></pre>
</li>
</ol>
<div class="supplemental">
<p><strong>Zu Bedenken</strong></p>
<p>Die gezeigte Operation löst die Ordnung in der Datei auf und sortiert diese alphabetisch. Dies ist aber häufig nicht gewünscht – insbesondere wenn der Leak nach Verwendungshäufigkeit sortiert ist!</p>
</div></div><div class="small ld-slide" id="szenario-5-kombination-von-worterbuch-mit-eigenem-regelsatz-2">
<h2>Szenario 5: Kombination von Wörterbuch mit eigenem Regelsatz</h2>
<p><strong>Angriff</strong></p>
<ol class="arabic">
<li><p>Erstellen des Regelsatzes: <span class="docutils literal">case.rule</span></p>
<p>Um sicherzugehen, dass wir alle Varianten abdecken, brauchen wir drei Regeln.</p>
<table class="incremental no-table-borders" style="width: 100%;">
<tbody>
<tr><td><p>cd</p></td>
<td><p><span class="peripheral">Erst Groß-Kleinschreibung anpassen und dann duplizieren.</span></p></td>
</tr>
<tr><td><p>dc</p></td>
<td><p><span class="peripheral">Erst duplizieren und dann Groß-Kleinschreibung anpassen.</span></p></td>
</tr>
<tr><td><p>d</p></td>
<td><p><span class="peripheral">Einfach nur duplizieren.</span></p></td>
</tr>
</tbody>
</table>
</li>
</ol>
<ol class="arabic incremental" start="2">
<li><p>Angriff mittels Hahcat</p>
<pre class="code bash literal-block"><code>hashcat<span class="whitespace"> </span>-m<span class="whitespace"> </span><span class="literal number">1700</span><span class="whitespace"> </span>hash.sha125<span class="whitespace"> </span>candidates.txt<span class="whitespace"> </span>-r<span class="whitespace"> </span><span class="keyword">case</span>.rule</code></pre>
</li>
</ol>
<div class="supplemental">
<p><strong>Tips</strong></p>
<p>Das beherrschen von regulären Ausdrücken ist bei der Passwortrekonstruktion sehr hilfreich.</p>
<p>Der folgende Ausdruck liefert zum Beispiel alle 4stelligen Worte aus Rockyou mit Hilfe eines Lookheads, dass längere Worte filtert.</p>
<pre class="code bash black literal-block"><code>$<span class="whitespace"> </span>grep<span class="whitespace"> </span>-Po<span class="whitespace"> </span><span class="literal string double">&quot;^[a-zA-Z]{3,4}(?=[^a-zA-Z])&quot;</span><span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace">     </span>/usr/share/wordlists/rockyou.txt</code></pre>
<p>Das Passwort <span class="docutils literal">TreeTree</span> würde sich damit erfolgreich wiederherstellen lassen.</p>
</div></div><div class="small ld-slide" id="szenario-6-kartesiche-produkt-von-zwei-worterbuchern">
<h2>Szenario 6: Kartesiche Produkt von zwei Wörterbüchern</h2>
<p><strong>Ausgangssituation</strong></p>
<p>Aufgrund von Social Engineering/Ermittlungen wissen wir, dass die Person sehr gerne zwischen deutschen Großstädten pendelt. Nachdem andere Versuche nicht zum Erfolge geführt habe, wollen wir jetzt Passworte der Art: &quot;BerlinHamburg&quot; testen.</p>
<p><strong>Angriff</strong></p>
<ol class="arabic incremental">
<li><p>Erstellen eines fokussierten Wörterbuchs durch <em>Googeln</em> von großen Städten.</p></li>
<li><p>Angriff durch Kombination des Wörterbuchs mit sich selbst.</p>
<pre class="code bash literal-block"><code>$<span class="whitespace"> </span>hashcat<span class="whitespace"> </span>-m<span class="whitespace"> </span><span class="literal number">1400</span><span class="whitespace"> </span>hash.sha256<span class="whitespace"> </span>-a<span class="whitespace"> </span><span class="literal number">1</span><span class="whitespace"> </span>big_cities2.txt<span class="whitespace"> </span>big_cities2.txt</code></pre>
</li>
</ol>
</div><div class="small ld-slide" id="szenario-7-worterbuch-mit-maske">
<h2>Szenario 7: Wörterbuch mit Maske</h2>
<p><strong>Ausgangssituation</strong></p>
<p>Es ist bekannt, dass die Passwörter der Gruppierung häufig mit vier Zahlen und zwei Sonderzeichen aus einer sehr kleinen Mengen von Sonderzeichen (<span class="docutils literal">$!.</span>) enden. Davor kommt ein Wort mit ca. 4-8 Stellen in den typischerweiser &quot;liebe/love/luv&quot; vorkommt.</p>
<p><strong>Angriff</strong></p>
<ol class="arabic simple incremental">
<li><p>Erstellen eines fokussierten Wörterbuchs: <span class="docutils literal">candidates.txt</span></p></li>
<li><p>Angriff mit passendem Maskenangriff</p></li>
</ol>
</div><div class="small ld-slide" id="szenario-7-worterbuch-mit-maske-1">
<h2>Szenario 7: Wörterbuch mit Maske</h2>
<p><strong>Angriff mit Hybridangriff</strong></p>
<p><span class="docutils literal">candidates.txt</span> enthält alle Begriffe aus rockyou, die die Anforderung erfüllen:</p>
<pre class="code bash literal-block"><code>$<span class="whitespace"> </span>grep<span class="whitespace"> </span>-oE<span class="whitespace"> </span><span class="literal string double">&quot;[a-zA-Z]*[Ll]((uv)|(ove)|(iebe))[a-zA-Z]*&quot;</span><span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace">      </span>/usr/share/wordlists/rockyou.txt<span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace"> </span><span class="punctuation">|</span><span class="whitespace"> </span>sort<span class="whitespace"> </span>-u<span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace"> </span>&gt;<span class="whitespace"> </span>candidates.txt</code></pre>
<p class="incremental">Angriff mit Hashcat:</p>
<pre class="code bash incremental literal-block"><code>$<span class="whitespace"> </span>hashcat<span class="whitespace"> </span>-m<span class="whitespace"> </span><span class="literal number">1400</span><span class="whitespace"> </span>hash.sha256<span class="whitespace"> </span>candidates.txt<span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace">    </span>-a<span class="whitespace"> </span><span class="literal number">6</span><span class="whitespace"> </span>-1<span class="whitespace"> </span><span class="literal string single">'$.!'</span><span class="whitespace"> </span><span class="literal string single">'?d?d?d?d?1?1'</span></code></pre>
<div class="supplemental">
<p><strong>Beispiel</strong></p>
<p>In diesem Falle verwenden wir einen Hybridangriff, der eine Wordliste mit einer Maske kombiniert. Hier definieren wir unseren eigenen „Zeichensatz“ mit dem Parameter <span class="docutils literal"><span class="pre">-1</span> <span class="pre">'$.!'</span></span> und referenzieren diesen in unserer Maske später mit <span class="docutils literal"><span class="pre">?1</span></span>.</p>
<p>Ein Beispielpasswort, dass wir mit dem Ansatz ermitteln könnten, wäre:</p>
<table class="monospaced">
<thead>
<tr><th class="head"><p>SHA256</p></th>
<th class="head"><p>Passwort</p></th>
</tr>
</thead>
<tbody>
<tr><td><dl class="simple">
<dt>b9cace43df57bc694498bf4d7434f45a</dt>
<dd><p>8466c4a924f608d54fd279d24b3dc937</p>
</dd>
</dl>
</td>
<td><p>ILuvU2023!!</p></td>
</tr>
</tbody>
</table>
</div></div><div class="small ld-slide" id="szenario-8-passworter-mit-muster">
<h2>Szenario 8: Passwörter mit Muster</h2>
<p><strong>Ausgangssituation</strong></p>
<p>Wir möchten ein Wörterbuch erstellen mit „Wörtern“, die Buchstabenvervielfältigungen enthalten, aber nicht länger als 16 Zeichen sind. Zum Beispiel: <span class="docutils literal">aaaaBBBBcccc</span> oder auch <span class="docutils literal">AFFFFFE</span>.
Weiterhin soll die Liste nach der Länge der gefundenen Einträge aufsteigend sortiert sein und Zeichen, die keine Buchstaben sind, einfach gelöscht werden.</p>
<p><strong>Lösung</strong></p>
<div class="incremental docutils container">
<p>Heraussuchen entsprechender Wörter aus rockyou mittels Linux Kommandozeilenwerkzeugen.</p>
<pre class="code bash literal-block"><code>$<span class="whitespace"> </span>grep<span class="whitespace"> </span>-E<span class="whitespace"> </span><span class="literal string double">&quot;([a-zA-Z])\1{3,}&quot;</span><span class="whitespace"> </span>/usr/share/wordlists/rockyou.txt<span class="whitespace">
  </span><span class="punctuation">|</span><span class="whitespace"> </span>grep<span class="whitespace"> </span>-E<span class="whitespace"> </span><span class="literal string double">&quot;^.{4,16}</span>$<span class="literal string double">&quot;</span><span class="whitespace">
  </span><span class="punctuation">|</span><span class="whitespace"> </span>sed<span class="whitespace"> </span>-E<span class="whitespace"> </span><span class="literal string single">'s/[^a-zAZ]//g'</span><span class="whitespace">
  </span><span class="punctuation">|</span><span class="whitespace"> </span>sort<span class="whitespace"> </span>-u<span class="whitespace">
  </span><span class="punctuation">|</span><span class="whitespace"> </span>awk<span class="whitespace"> </span><span class="literal string single">'{print length &quot; &quot; $1}'</span><span class="whitespace">
  </span><span class="punctuation">|</span><span class="whitespace"> </span>sort<span class="whitespace"> </span>-n<span class="whitespace">
  </span><span class="punctuation">|</span><span class="whitespace"> </span>sed<span class="whitespace"> </span>-E<span class="whitespace"> </span><span class="literal string single">'s/^[0-9]+ //'</span></code></pre>
</div>
<div class="supplemental">
<p><em>Alternative Aufgabenstellung</em></p>
<p>Sortierung der finalen Liste nach nach der Häufigkeit der Muster, angefangen mit dem häufigsten Mustern.</p>
</div></div><div class="small ld-slide" id="szenario-9-passworter-bestehend-aus-fragmenten">
<h2>Szenario 9: Passwörter bestehend aus Fragmenten</h2>
<p><strong>Ausgangssituation</strong></p>
<ul class="simple">
<li><p>Einer gegebenen Liste können wir nur entnehmen, dass alle Passwörter zusammengesetzt sind aus den Fragmenten: <span class="docutils literal">ab</span>, <span class="docutils literal">mem</span>, <span class="docutils literal">li</span> und <span class="docutils literal">xy</span>.</p></li>
<li><p>Darüber hinaus ist immer eine Zahl vorangestellt und am Ende kommt ein Punkt (<span class="docutils literal">.</span>) oder ein Ausrufezeichen (<span class="docutils literal">!</span>).</p></li>
<li><p>Die Länge scheint zwischen 6 und 16 Zeichen zu sein und Fragmente können sich wiederholen.</p></li>
</ul>
<p>Beispiel: <span class="docutils literal">1ablixyxy.</span></p>
<p><strong>Vorgehen</strong></p>
<ol class="arabic simple incremental">
<li><p>Erstellen eines Basiswörterbuchs (<span class="docutils literal">base.txt</span>) mit den Fragmenten als Einträge.</p></li>
<li><p>Erstellen von Regeln für das Voranstellen und Anhängen der entsprechenden (Sonder)zeichen.</p></li>
<li><p>Aus Basiswörterbuch das finale Wörterbuch für den Angriff generieren.</p></li>
<li><p>Mit dem finalen Wörterbuch und entsprechenden Regeln angreifen.</p></li>
</ol>
</div><div class="small ld-slide" id="szenario-9-generierung-von-worterbuchern-aus-fragmenten">
<h2>Szenario 9: Generierung von Wörterbüchern aus Fragmenten</h2>
<p><strong>Lösung</strong></p>
<p>Zu Generierung aller Kombinationen aus den Fragmenten verwenden wir den Princeprocessor.  Der Princeprocessor ist sehr schnell und ermöglicht es in Fällen die Ausgabe direkt an Hashcat durchzureichen und das Zwischenwörterbuch nicht explizit speichern zu müssen.</p>
<p><strong>Angriff</strong></p>
<pre class="code bash literal-block"><code>$<span class="whitespace"> </span>princeprocessor<span class="whitespace"> </span>--pw-min<span class="operator">=</span><span class="literal number">6</span><span class="whitespace"> </span>--pw-max<span class="operator">=</span><span class="literal number">16</span><span class="whitespace"> </span>base.txt<span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace">  </span><span class="punctuation">|</span><span class="whitespace"> </span>hashcat<span class="whitespace"> </span>-m<span class="whitespace"> </span><span class="literal number">1400</span><span class="whitespace"> </span>hash.sha256<span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace">     </span>-r<span class="whitespace"> </span>number_prepend.rule<span class="whitespace"> </span><span class="literal string escape">\
</span><span class="whitespace">     </span>-r<span class="whitespace"> </span>sc_append.rule</code></pre>
<div class="supplemental">
<p><em>Aufbau von</em> <span class="docutils literal">number_prepend.rule</span>:</p>
<pre class="code bash black literal-block"><code>^0<span class="whitespace">
</span>^1<span class="whitespace">
</span>...<span class="whitespace">
</span>^9</code></pre>
<p><em>Aufbau von</em> <span class="docutils literal">sc_append.rule</span>:</p>
<pre class="code bash black literal-block"><code>$.<span class="whitespace">
</span><span class="name variable">$!</span></code></pre>
<p>Mit dem obigen Ansatz könnte zum Beispiel das folgende Passwort ermittelt werden:</p>
<table>
<thead>
<tr><th class="head"><p>SHA256</p></th>
<th class="head"><p>Passwort</p></th>
</tr>
</thead>
<tbody>
<tr><td><p>8b11f8e8d487266a791d6d723a3e380c
38f49679735a7f3395ace4302e83dd0e</p></td>
<td><p>8abxylixy.</p></td>
</tr>
</tbody>
</table>
<p>In diesem Falle wäre es auch möglich gewesen nur einen Regelsatz zu erstellen mit den passenden Regeln (zum Beispiel: <span class="docutils literal">^1$.</span>, <span class="docutils literal">^1$!</span>, ...) der Aufwand wäre hier jedoch höher gewesen und hätte keinen Nutzen gehabt.</p>
<p>Im Allgemeinen ist jedoch bei der Verwendung des Kreuzproduktes von Regeln immer darauf zu achten, dass keine (oder zumindest keine relevante Anzahl von) Regeln dupliziert werden. Ein Beispiel wäre das Kreuprodukt aus einem Regelnsatz für das optionale Anhängen einer Ziffer mit sich selbst. Sei der Regelsatz:</p>
<pre class="code black literal-block"><code>:
$1
$2</code></pre>
<p>und würde man diesen mit sich selber kombinieren, um alle Fälle des Anhängens von keiner, einer bzw. zwei Zahlen abzudecken, dann würden folgende Regeln entstehen:</p>
<pre class="code black literal-block"><code>::
:$1
:$2
$1$1
$1$2
$2$1
$2$2
$1:
$2:</code></pre>
<p>Wie zu erkennen ist, führen zum Beispiel die Regeln <span class="docutils literal">$1:</span> und <span class="docutils literal">:$1</span> jeweils zum gleichen Ergebnis und wären deswegen nicht effektiv.</p>
</div></div><div class="small ld-slide" id="szenario-10-hashcat-als-werkzeug-zur-worterbuchgenerierung">
<h2>Szenario 10: Hashcat als Werkzeug zur Wörterbuchgenerierung</h2>
<p><strong>Ausgangssituation</strong>
Gegeben sein 3 Wörterbücher <a class="brackets" href="#footnote-1" id="footnote-reference-1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>: <span class="docutils literal">base1.txt</span>, <span class="docutils literal">base2.txt</span> und <span class="docutils literal">base3.txt</span>. Gesucht ist ein Wörterbuch, dass alle Kombinationen aus den drei Wörterbüchern enthält und bei dem alle Teilworte immer mit Sonderzeichen (-) voneinander getrennt sind.</p>
<div class="incremental docutils container">
<p><strong>Beispiel</strong>
Sei <span class="docutils literal">base1.txt</span>: <em>Kuh</em>, <em>Schwein</em>; <span class="docutils literal">base2.txt</span>: <em>Haus</em>, <em>Villa</em> und <span class="docutils literal">base3.txt</span>: <em>Baum</em>, <em>Busch</em>. Dann wäre das gesuchte Wörterbuch: <em>Kuh-Haus-Baum</em>, <em>Kuh-Haus-Busch</em>, ..., <em>Schwein-Villa-Busch</em>.</p>
</div>
<div class="incremental docutils container">
<p><strong>Vorgehen</strong></p>
<div class="incremental docutils container">
<ol class="arabic simple">
<li><p>Erzeugen des Kreuzprodukts der ersten beiden Wörterbücher.</p></li>
</ol>
<pre class="code bash literal-block"><code>$<span class="whitespace"> </span>hashcat<span class="whitespace"> </span>--stdout<span class="whitespace"> </span>base1.txt<span class="whitespace"> </span>base2.txt<span class="whitespace"> </span>-j<span class="whitespace"> </span><span class="literal string single">'$-'</span><span class="whitespace"> </span>&gt;<span class="whitespace"> </span>base1-base2.txt</code></pre>
</div>
<div class="incremental docutils container">
<ol class="arabic simple">
<li><p>Erzeugen des finalen Wörterbuchs durch Bildung des Kreugprodukts der Ergebnisse aus Schritt 1 mit dem dritten Wörterbuch.</p></li>
</ol>
<pre class="code bash literal-block"><code>$<span class="whitespace"> </span>hashcat<span class="whitespace"> </span>--stdout<span class="whitespace"> </span>base1-base2.txt<span class="whitespace"> </span>base3.txt<span class="whitespace"> </span>-j<span class="whitespace"> </span><span class="literal string single">'$-'</span><span class="whitespace"> </span>&gt;<span class="whitespace"> </span>final.txt</code></pre>
</div>
</div>
<div class="supplemental">
<p>Die Hashcat Utilities Bibliothek hat auch noch weitere Werkzeug zum Kombinieren von Wörterbüchern, die viele Fälle sehr effizient abdecken (auch den besprochenen). Jedoch ist es gerade in Fällen, in denen komplexere Regeln zur Anwendung kommen sollen, häufiger sinnvoller/nowendig direkt Hashcat im &quot;stdout&quot; Modus zu verwenden, um die Zwischenwörterbücher zu generieren.</p>
</div><aside class="footnote-list brackets">
<aside class="footnote brackets" id="footnote-1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#footnote-reference-1">1</a><span class="fn-bracket">]</span></span>
<p>Die selbe Vorgehensweise lässt sich auch anwenden, wenn man ein Wörterbuch mit sich selber kombinieren möchte.</p>
</aside>
</aside>
</div><div class="ld-slide" id="passworter-angreifen-zusammenfassung">
<h2>Passwörter angreifen - Zusammenfassung</h2>
<ul class="incremental more-space-between-list-items simple">
<li><p>Passwörter können vielfach effizient angegriffen werden.</p></li>
<li><p>(gute bis exzellente) Kenntnisse über die Zielpersonen sind häufig notwendig.</p></li>
<li><p>Viele Werkzeuge sind verfügbar (siehe auch Hashcat Werkzeuge, Princeprocessor, John the Ripper, etc.)</p></li>
<li><p>Kleine etablierte Kommandozeilenwerkzeuge (<span class="docutils literal">tr</span>, <span class="docutils literal">greb</span>, <span class="docutils literal">sed</span>, <span class="docutils literal">awk</span>, ...) oder selbstentwickelte Werkzeuge (zum Beispiel in Python) sind häufig ergänzend notwendig und führen oft  schneller zum Ziel als die Suche nach <em>dem</em> Tool.</p></li>
<li><p>Insbesondere wenn es um die semantische Anreicherung von Wörterbüchern geht, dann sind (bisher) keine etablierten Werkzeuge vorhanden.</p></li>
<li><p>Häufig führen nur Kombinationen von etablierten und eigenen Werkzeugen zum gewünschten Ziel.</p></li>
</ul>
</div><div class="integrated-exercise transition-move-to-top ld-slide" id="ubung">
<h2>Übung</h2>
<p><strong>Wörterbuch basierte Wiederherstellung eines Passworts</strong></p>
<div class="ld-exercise" data-exercise-id="1" data-exercise-title="1 - MD5 Hash eines einfachen Passworts" id="ld-exercise-1">
<p class="ld-exercise-title rubric">MD5 Hash eines einfachen Passworts</p>
<pre class="code text copy-to-clipboard literal-block"><code>7c6a180b36896a0a8c02787eeafb0e4c</code></pre>
<p>Hinweise: Das Passwort besteht aus Buchstaben gefolgt von Ziffern und ist sehr häufig.</p>
<p>Sie können Hashcat (<a class="reference external" href="https://hashcat.net/hashcat/">https://hashcat.net/hashcat/</a>) verwenden oder ein Bash-Skript schreiben oder eine kleine Lösung in einer Programmiersprache Ihrer Wahl entwickeln. Verwenden Sie ggf. eine
Liste bekannter Passwörter (z. B. Rockyou).</p>
<div class="ld-exercise-solution" data-encrypted="true">
MTAwMDAw:lveL96GnwGqei0JYTIc+DY1tIyJr4iWcn8zxZ2TGIME=:Qw1Tnc9C0N3nfQPI:1+W4zNgT3LwV424jaWXWjc8sGhDp89BcU7vP+OFMgGjCciR3ColRR+TV0QBTHIDGub319Uujo6iv0s2ZOvrFsYytn4EuH3rq5162h5Sl6QzLZG5c4swJfXQ=</div>
</div>
</div>
</template>
</body>
</html>
